### 2.1 운영체제의 목적과 기능

: 운영체제는 응용 프로그램의 수행을 제어하고 응용 프로그램과 컴퓨터 하드웨어 사잉의 인터페이스 역할을 하는 프로그램이다. 운영체제의 목적으로는 다음과 같은 3가지를 들 수 있다.

1. 편리성: 운영체제는 컴퓨터를 보다 편리하게 사용할 수 있게 해준다.
2. 효율성: 운영체제는 컴퓨터 시스템 자원을 효율적으로 사용할 수 있게 해준다.
3. 발전성: 운영체제는 효과적인 개발과 시험이 가능해야하고, 서비스를 방해하지 않고 새로운 시스템 기능을 도입할 수 있도록 구축되어야 한다.

    <aside>
    💡

    1. 유지보수와 확장 용이성
    - 운영체제는 새로운 기능을 추가하거나 기존 기능을 수정할 때 전체 시스템을 중단하지 않고 서비스를 계속 제공하면서 업데이트가 가능해야 합니다.
    1. 기술 발전 수용
    - 새로운 하드웨어(예: SSD, 멀티코어 CPU, 새로운 입출력 장치)나 소프트웨어 기술이 등장했을 때, 운영체제가 그것을 지원할 수 있도록 확장 가능해야 합니다.
    1. 사용자 요구 변화 대응
    - 사용자가 요구하는 새로운 기능(예: 보안, 가상화, 컨테이너 기술 등)을 운영체제가 수용할 수 있는 구조여야 합니다.
    </aside>


---

*****사용자/컴퓨터 인터페이스로서의 운영체제**

: 프로그래머가 하나의 응용 프로그램(어플)을 개발할 때 하드웨어 제어를 완전히 담당하는 기계명령어의 집합으로 프로그램을 개발한다면, 굉장히 복잡한 작업을 처리해야한다. 이러한 복잡한 개발 과정의 처리를 쉽게 하기 위해 다양한 시스템 프로그램들이 제공되는데, 이를 유틸리티(utility) 혹은 라이브러리 프로그램이라고 부른다. 그래서 응용 프로그램은 수행하기 위해 유틸리티나 라이브러리를 활용한다. 그래서 가장 중요한  시스템 프로그램들을 모아놓은 것이 운영체제라고 할 수 있다.

- 짤막 상식: OS는 주로 어셈블리언어와 C, C++로 대부분 제작됨 (해당 OS의 라이브러리와 유틸리티도 마찬가지 )

- 운영체제는 하드웨어에 관한 상세한 것을 프로그래머에게 숨기고, 시스템을 편리하게 사용할 수 있게 해주는 인터페이스를 제공한다. 즉, 운영체제는 프로그래머와 응용 프로그램이 그와 같은 기능과 서비스에 쉽게 접근하고 편리하게 사용할 수 있게 해주는 중재자로서의 역할을 한다.

짤막상식: 시스템콜이란?

: 사용자 프로그램이 운영체제 기능을 사용할 때 운영체제에게 요청하는 것을 뜻하며, 사용자 프로그램과 운영체제 사이의 bridge역할을 한다. 즉 사용자 프로그램은 직접 커널에 접근하지 않고 운영체제에게 요청을 하면 운영체제가 대신 일을 하며, 시스템상 안전성을 지킴.

- 운영체제의 역할
    - 프로그램 개발
    - 프로그램 실행
    - 입출력 장치 접근
    - 파일 접근 제어
    - 시스템 접근
    - 에러 발견 및 응답
    - 어카운팅
    - 인스트럭션 셋 구조(ISA)
    - 응용 실행 파일 인터페이스(ABI)
    - 응용 프로그래밍 인터페이스(API)

ISA란(Instruction Set Architecture)?

- ISA(Instruction Set Architecture)는 하드웨어와 소프트웨어(CPU와 운영체제) 사이의 **인터페이스** 역할을 하는, **기계어 명령어들의 집합**을 정의한 구조이다. CPU가 수행할 수 있는 저수준의 명령어들을 정의하고 있으며, **운영체제는 이 명령어들을 이용해 CPU를 제어하고 자원을 관리**한다.
    - 운영체제는 이 ISA에 맞춰 프로그램을 작성해야하며, 대표적인 ISA 종류는 아래와 같다.
        - CISC (Complex Instruction Set Computer)
            - **복잡한 명령어를 적게 써서 일을 많이 하도록** 설계
            - ex) x86 (intel, AMD, Linux), MIPS
                - 장점:
                    - 고급 명령어 제공 → **코드 크기 작고 개발 편의성↑**
                    - 복잡한 작업을 적은 명령어로 처리 가능
                - 단점:
                    - 명령어 해석이 복잡하고 느림
                    - CPU 설계와 회로 구현이 어려움
        - RISC (Reduced Instruction Set Computer)
            - 명령어를 **간단하고 정형화된 소수**만 제공
            - ex) ARM (스마트폰, 임베디드), MIPS, RISC-V
                - 장점:
                    - **단순한 하드웨어 구조** → 고성능, 저전력에 유리
                    - 명령어 실행 속도 빠름
                - 단점:
                    - 하나의 작업을 위해 **더 많은 명령어 필요** → 코드 길이 증가
                    - 복잡한 연산을 하려면 여러 명령어를 조합해야 함

<메모리 상의 주소- 이미지>


- 예시 대상 : **MIPS Instruction Set**
    - 1980년대에 개발된 **RISC(Reduced Instruction Set Computer)** 구조의 CPU이다.
    - ARM이나 x86만큼 많이 쓰이진 않지만, 일부 임베디드 시스템에서는 여전히 사용되고, 명령어 구조가 단순하고 효율적이어서 **교육용으로 많이 사용됨**
- 특징:
    - 각 명령어의 크기가 32bit이다. (RISC라서 고정크기)
    - 명령어는 **연산, 메모리 접근, 분기 등 기본적인 연산**을 수행
        - 크게 3가지의 타입으로 구성되어 있음
            - J-type
            - I-type
            - R-type
    - J-type이란?
  

: opcode(Opertaion code로 add, print, delete 등 핵심 수행 코드를 뜻함)와 이동할 주소를 나타내는 명령어 구조로 규칙을 정해놓은 J-type방식

- I-type이란?

: opcode + 근원 레지스터 + 대상 레지스터 + 즉시 값

<aside>
💡

ex)
addi $t0, $t1, 5
→ opcode: 001000       (addi)
→ rs:     01001         ($t1 = 9)
→ rt:     01000         ($t0 = 8)
→ imm:    0000 0000 0000 0101 (5)

→ 전체:  001000 01001 01000 0000 0000 0000 0101

</aside>

- R-type이란?


: R타입에서 결과값 저장하는 레지스터는 destination register이고 source , target이 첫번째 두번째 연산 값이 된다. 그리고 shift연산이 있는경우 ( 2^n) shift amount에 코드가 입력되고, function이 덧셈, 뺄셈과 같은 식별 코드이다. R 타입에서 opcode는 000000으로 고정되며, opcode가 000000이라면, cpu는 R-type이라고 인식하고 function을 확인한다.

결론: ISA방식에 맞춰 어셈블리어 코드 위치를 정해야한다. ISA가 맞지 않는 어셈블리언어를 사용하게 되면, cpu가 이해하지 못한다. 명령어 쓰인 방식이 다르기 때문.

참고자료 :

https://www.youtube.com/watch?v=1KTW32xSs_k
https://velog.io/@onegyeol/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94


ABI란(Application Binary Interface)?

- OS와 응용 프로그램 사이에서 바이너리 수준에서 정해놓은 규칙입니다.
- 목적
    - 컴파일된 바이너리 코드가 서로 다른 시스템 환경에서도 일관되게 작동될 수 있도록 하기 위함이다.
- 특징
    - 어떤 레지스터에 값을 저장하는지, 어디에 변수값을 저장하는 지 등.
    - 응용프로그램에서 작성된 코드가 컴파일될 때, 결국은 컴파일러가 OS ABI에 맞게 컴파일되어야함.

- Window의 경우 x86 ISA를 기반으로 OS가 제작되었기 때문에, x86 ABI 규약을 따른다.
    - 이 규약에 맞게 x86/x64 아키텍처 어셈블리어를 사용함
        - MASM (Microsoft Macro Assembler): 마이크로소프트에서 제공하는 Windows용 대표 어셈블러, MASM = 어셈블리어 → 기계어 변환함
            - ex) 어셈블리어 → 기계어 변환 예시

            ```nasm
            mov ax, num1      → A1 00 00     ; 메모리 주소 [num1] → AX
            add ax, num2      → 03 06 02 00  ; 메모리 주소 [num2] 값을 AX에 더함
            mov result, ax    → A3 04 00     ; AX 값 → [result] 메모리 저장
            mov ah, 4Ch       → B4 4C        ; AH 레지스터에 0x4C 저장
            int 21h           → CD 21        ; DOS 인터럽트 21h 호출 (프로그램 종료)
            ```


API란(Application Programming Interface**)**?

- 응용 소프트웨어 모듈 간 상호작용을 정의하는 규칙과 명령의 집합이다. 개발자들이 다른 복잡하게 구현된 비즈니스 로직들을 추상화시켜 api로 만들어 놓은 것이다.
    - 자바로 예를 들면, java.util.List, java.lang.String나 스프링 프레임워크, DB 드라이버 라이브러리 등이 있다.

< 프로그램 실행 흐름 = ISA / ABI / API 흐름 이미지 >

결론

- ISA = 기계가 이해하는 언어 문법서
- ABI = 사람들이 그 문법을 써서 소통하는 규칙집
    - ISA: 이 명령어는 어떻게 생겼는가? → opcode 어디, rs 어디?
    - ABI: 이 명령어가 함수 안에서 쓰일 때 → `$t0`는 임시 레지스터로 써도 되나? 함수 인자 전달용인가?
        - ABI는 ISA기반으로 만들어 지기에 둘은 굉장히 밀접한 관계에 있음.

---

*** **자원 관리자로서의 운영체제**

: 컴퓨터는 데이터의 이동/저장/처리와 이들 기능을 제어하는데 필요한 자원들의 집합이다. 운영체제는 이들 자원의 관리를 책임진다.

- **운영체제가 관리하는 자원들 종류**

| 자원 종류 | 운영체제의 자원 관리 기능 |
| --- | --- |
| **CPU (중앙처리장치)** | - 여러 프로세스에게 CPU를 적절히 배분 (CPU 스케줄링)- 하나의 CPU를 여러 프로그램이 공정하게 공유할 수 있도록 함 |
| **메모리 (RAM)** | - 각 프로세스에게 메모리 공간을 할당하고 해제- 프로세스 간 메모리 충돌 방지- 가상 메모리 시스템 제공 |
| **저장장치 (디스크 등)** | - 파일 시스템을 통해 파일 저장 및 접근 관리- 디스크 스케줄링을 통해 성능 향상 |
| **입출력 장치 (I/O)** | - 키보드, 마우스, 프린터 등 장치 접근을 제어- 장치 드라이버를 통해 하드웨어와 응용 사이를 중계 |
| **프로세스** | - 프로세스 생성, 실행, 종료 관리- 각 프로세스에 자원을 할당하고 상태를 유지 |
| **네트워크 자원** | - 네트워크 연결, 포트, 데이터 전송 등 관리- 통신 자원에 대한 접근 제어 및 보안 관리 |

- **운영체제가 자원 관리하는 방식**
    - **커널**을 핵심으로 아래의 방식들이 있다.
        - 스케줄링
        - 할당과 회수
        - 동기화와 상호배제
        - 보호와 보완