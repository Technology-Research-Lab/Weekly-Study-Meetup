(3) 운영체제 2

**주제: 멀티 프로세스/멀티 스레드**

시작에 앞선 용어정리

1. 멀티 프로세싱 : 여러 cpu 하나의 주메모리로 하나 프로그램을 여러 cpu로 실행시키는거
2. 시분할 시스템: 여러 사용자에게 하나의 컴퓨터가 다양한 프로그램 실행을 분산적으로 처리함으로써 사용자는 기다림없이 여러개의 프로그램이 실행되고 있지만, 자기가 실행하는 프로그램만 실행되고 있다고 느끼게 하는것
3. 멀티 프로그래밍: 하나의 주기억장치에 여러 프로그램을 실행시키는 것
4. 대화형 시스템: 사용자의 입출력에 반응하여 즉시 응답하는 것
5. 다중 모드 처리 시스템 : 일괄 처리 시스템, 시분할 시스템, 멀티 프로세싱, 대화형 시스템을 한 시스템에서 모두 제공하는 방식입니다.
6. 분산 처리 시스템 : 여러 컴퓨터가 네트워크 상 연결되어 하나의 프로그램 혹은 여러 프로그램을 분산해서 실행 시키는 것
7.

### 프로세스란

- 수행중인 프로그램
- 컴퓨터 상에 수행중인 프로그램의 인스턴스 (인스턴스란 : 실제로 메모리에 올려 실행 중인 구체적인 개체)
- 처리기에 할당되어 수행될 수 있는 개체(entity)
- 명령들의 순차수행, 현재 상태, 연계된 시스템 자원들의 집합등에 의해 특징 지어지는 활성화 단위 (a unit of activity)
- 필수적인 요소( **프로그램 코드**, **코드와** **연계된 데이터 집합** )가 있다.

### 프로세스 제어 블록: PCB(process control block)란?

: 프로세스를 실행시키면, 운영체제가 PCB를 생성하여, 실행되는 프로세스에 대한 정보들을 저장하고, 큐에 넣어서 관리한다. 즉, 운영체제가 프로세스를 관리하기 위해서 따로 저장해놓은 공간이라고 보면된다. 그리고 PCB들이 이제 상태 큐, 준비 큐 같은 자료구조에 들어가서 관리된다.

![image.png](attachment:ee431810-b263-48d8-b808-21d775c01726:image.png)

PCB에 포함되는 대표적인 정보

- **PID**
- **프로세스 상태**
- **CPU 스케줄링 정보**
    - 우선순위
    - 어카운팅 정보( 사용된 처리기 시간, 클록 시간, 프로세스에 의해 사용중인 파일들의 리스트)
- **메모리 정보**
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 페이지 테이블 정보 ( 페이징에서 사용되는 페이지 테이블 정보를 뜻함)
        - OS에서 페이징이란?
            - 실제 메모리는 프로세스가 필요로하는 모든 정보를 메모리에 담을 수 없다. (이전에 배운 캐시와 비슷하다). 그렇기에 페이징이라는 방법을 이용해서 1~10까지의 정보만 메모리에 할당하고, 11~20의 정보는 필요로 할 때 이전의 정보를 지우고, 메모리에 다시 보조디스크로 부터 정보를 받아와 메모리에 적재시키고 cpu가 실행하도록 하는 방법이다. 이 개념에서 논리 메모리 주소가 사용되며, 이때 논리 메모리 주소를 실제 메모리 주소로 변환하는 역할을 하는 것이 MMU (Memory Management Unit, 메모리 관리 장치이다.
- **사용한 파일과 입출력 장치 정보**
    - 할당된 입출력장치, 사용중인(열린) 파일 정보
- **문맥 데이터(context data)** = 레지스터 정보랑 같은 말 : 프로세스가 수행중일 때 처리기의 레지스터에 존재하는 데이터.

- PCB

  ![KakaoTalk_20250803_191002634.jpg](attachment:9ad650df-3bcf-4c66-b2f4-2dd42acbfe4a:KakaoTalk_20250803_191002634.jpg)


**프로세스 궤적( Process Trace)**

: cpu입장에서 프로세스는 PC 값에 의해 결정된 순서에 따라 명령어를 수행한다. 개별 프로그램의 관점으로 프로그램의 수행은 자신에 속한 일련의 명령어들의 수행이고, 개별 프로세스 행위의 특성은 그 프로세스를 수행하기 위한 일련의 명령어 리스트로 표현된다. **이 프로세스의 일련의 명령어 리스트를 프로세스의 궤적(Trace)라고 한다.**

예시)

주 기억장치(memory)에 완전히 적재된 3개의 프로세스가 있다. (A, B, C) 그리고 프로세스를 교체해주는 디스패처(dispatcher) 프로그램이 있다.

프로세스 A는 12개의 명령어, B는 4개 8003은 입출력 명령어, C는 12개로 이루어져있다.

![image.png](attachment:2ec85d62-dadf-497e-a166-6976835d6f62:image.png)

![image.png](attachment:cd406e1e-eda2-4567-a368-f8ac46a4f60c:image.png)

---

![image.png](attachment:ddffdc21-6a2e-43f9-b4bd-70c18273cbbd:image.png)

![image.png](attachment:cd406e1e-eda2-4567-a368-f8ac46a4f60c:image.png)

: 위 이미지는 처리기의 관점에서 본 것이다. 총 52개의 명령어 사이클의 수행을 진행하였고, CPU는 최대 6개의 명령어 사이클 동안만 연속 수행되고, 디스패처는 동일 순차 명령어들이 수행하고있다.

---

**실제 예시로 보자면…**

: 메모장이라는 응용프로그램이 있고, 안에는 여러 프로세스들이 있다.

- 주요 프로세스 종류

  ### 1. 리얼타임 프로세스 (Real-time Process)

    - 정해진 시간 내에 반드시 작업을 완료해야 함
    - 하드 리얼타임(엄격한 시간 제한), 소프트 리얼타임(유연한 시간 제한)으로 구분

  ### 2. 배치 프로세스 (Batch Process)

    - 사용자 개입 없이 묶음 단위 작업 처리
    - 주로 백그라운드에서 실행됨

  ### 3. 대화형 프로세스 (Interactive Process)

    - 사용자와 실시간 상호작용
    - 빠른 응답성 요구

  ### 4. 시스템 프로세스 (System Process)

    - 운영체제의 핵심 기능 수행
    - 사용자에게는 보이지 않는 경우가 많음

    ---

  ### 5. 데몬 프로세스 (Daemon Process)

    - 백그라운드에서 계속 실행되는 서비스 프로세스
    - 시스템 시작 시 자동 실행되고, 요청 시 기능 제공
    - 예) 웹 서버, 프린터 서비스, 로그 기록 등

  ### 6. 유틸리티 프로세스 (Utility Process)

    - 시스템 유지보수나 관리 목적의 프로세스
    - 예) 디스크 검사, 백업 도구, 바이러스 검사기

  ### 7. 사용자 프로세스 (User Process)

    - 일반 사용자가 실행하는 응용 프로그램 프로세스
    - 예) 워드 프로세서, 웹 브라우저, 게임 등

  ### 8. 좀비 프로세스 (Zombie Process)

    - 실행은 끝났지만, 부모 프로세스가 종료 상태를 아직 확인하지 않은 프로세스
    - 시스템 자원을 약간 점유함

  ### 9. 오르펀 프로세스 (Orphan Process)

    - 부모 프로세스가 먼저 종료되어, 시스템이 다른 프로세스(예: init 프로세스)가 책임지는 프로세스

![image.png](attachment:81c798c3-5add-4bb2-95a1-d49ea4aeee6c:image.png)

### 문맥 교환 (Context Switch)

→ 프로세스가 다른 프로세스로 실행순서를 cpu를 변경할 때, 그 변경을 context switch라고 한다.

- 중단했던 프로세스를 다시 시작할 때 PCB에 저장된 내용을 복구한다.

![image.png](attachment:378ccfa4-8e8d-4fff-8d31-b52d4065816a:image.png)

![image.png](attachment:2e0b623c-83ad-4ae7-8d8d-b05fbe490370:image.png)

**실제로 간단한 운영체제가 프로세스를 관리하는 것을 나타내자면 이렇다.**

![image.png](attachment:6a1726d9-7613-4a17-a4c1-b2c547203391:image.png)

→ 이 간단한 모델을 통해서 운영체제 설계 요소 중 몇 가지를 이해할 수 있다.

: 단순하게 PCB를 큐에 적재하고, 실행하고, 디스패처를 이용해 중지 상태 or 완료 상태로 만드는 것을 볼 수 있다.

요점은 → 운영체제가 프로세스를 계속 추적하고 상태를 관리하고 하기 위해서는 프로세스와 그와 관련된 정보들을 가지는 인스턴스 즉 저장공간이 필요하다는 것인데 그것이 바로 PCB이다.

### 프로세스 생성과 종료

: 프로세스는 생성하고 종료된다.

- 생성은 몇가지 이유들이 있는데, 그 중 대화형 프로세스가 있다. 즉 사용자의 입력과 같이 동적인 이벤트에 의해 생성되는데, 이때 프로세스는 프로세스를 생성할 수 있어 효율적이게 동작한다. 부모 프로세스는 프로세스를 생성한 프로세스고, 자식 프로세스는 부모에 의해 태어난 프로세스이다.
- 프로세스 종료는 정상완료, 메모리 부족….. 부모 종료, 부모 요청 등에 의해서 종료될 수 있는데, 부모가 종료되면 자식도 종료된다는 규칙을 가지고 있다.

### 프로세스 상태

1. **생성 상태(New state)**
    1. pcb를 할당 방금 막 받은 상태 → PCB가 생성되었다 할 지라도, 아직 주기억장치에 적재되지 않은 상태 , 프로세스 풀(pool)에 아직 진입이 허용되지 않은 상태
2. **준비 상태(Ready state)**
    1. cpu에서 실행될 수 있는 상태
    2. 자신의 차례가 아니기에 기다리고 있는 상태
    3. 준비 → 실행으로 상태가 변경되는 것을 (디스패치 된다) 라고 함. **( 디스패처가 이 역할을 수행한다)**
3. **실행 상태(Running state)**
    1. cpu에서 실행하고 있는 상태
4. **대기 상태(Blocked state)**
    1. 프로세스가 실행 도중 (입출력 장치를 사용과 같은) 대기해야하는 상황 일 경우 대기상태로 변경시키고 다른 프로세스를 실행시킴.
    2. 입출력 완료 인터럽트를 받으면, 실행이 아닌 **준비 상태**가 된다.
    3. (대기상태에서 준비 상태로 변경되는 트리거는 OS의 커널 내부의 이벤트 처리 시스템이 담당하며, 인터럽트와 같은 이벤트를 감지하면 대기 상태의 프로세스를 준비 상태로 변경시킴)
        1. 이땐 블락 상태의 프로세스들이 대형 운영체제에서는 존재하게 되는데, 그래서 각 이벤트 마다 블록 큐를 두어 효율적으로 사용하기도 한다.
5. **종료 상태(Terminate state)**
    1. 프로세스가 종료된 상태, 프로세스 풀(pool)에서 방출된 상태
    2. PCB 삭제, 프로세스의 메모리 영역 정리

**프로세스 다이어그램**

![image.png](attachment:692d76a6-6d4e-44a6-b497-1eb914a32530:image.png)

***** 스와핑 (Swapping**)

: 스와핑은 준비 **상태 큐**에 존재하는 프로세스들이 **주기억장치 용량이 작아** 모두 적재되지 않는 상황일 때 대기 상태 큐에 존재하는 프로세스들을 **보류 큐**(suspended queue)에 적재시키고, **보조기억장치**로 옮긴다. 옮겨진 프로세스들은 메모리에서 제거한다. 이를 **스와핑**이라고 하고, 이러한 동작을 **스왑아웃**이라고 한다. 이 방법은 **보류 상태**라는 새로운 상태를 추가해야한다.

### 프로세스 이미지( = 프로세스의 메모리 영역 )

: 프로세스는 준비단계로 상태가 변하면서 메모리에 적재되는데, 이때 운영체제는 프로세스 이미지를 만들어 메모리에 적재시킨다. 프로세스 이미지는 몇가지의 정보들이 영역으로 나뉘며 저장되는데, 크게 코드, 데이터, 스텍, 힙, PCB 영역으로 분리된다.

→ https://zangzangs.tistory.com/107

- **코드 영역**: 명령어 모음
- **데이터 영역**: 전역변수
- **스텍 영역**: 일시적 저장 공간 ( 지역변수, 매개변수)
- **힙 영역**: 프로그래머가 직접 할당할 수 있는 저장공간 (클래스, 인스턴스)
    - 스택,힙은 동적으로 메모리 크기가 변하기 때문에, 이미지 처럼 서로 반대되는 방향으로 크기가 커진다. 둘이 만나면, 메모리 꽉찬것.
- **PDB 정보**

![image.png](attachment:0f04fc8e-f24a-499d-abe2-c6f70031c724:image.png)

---

### 멀티 프로세스

: 여러 프로세스를 CPU에 인터리빙하며, 프로세스를 여러개 실행했다 중단했다 하며 하는 것이다.

![image.png](attachment:d02a4adb-3e22-40f7-a46d-f42726122818:image.png)

**프로세스 탐색기로 프로세스를 확인할 수 있다.(window 제공 툴)**

1. [**https://learn.microsoft.com/ko-kr/sysinternals/downloads/process-explorer**](https://learn.microsoft.com/ko-kr/sysinternals/downloads/process-explorer)

그렇다면 어떻게 cpu는 어떻게 프로세스들의 우선순위를 매기는가?

→ 이는 운영체제(OS)가 담당하는 역할로, 스케줄러를 통해서 프로세스들을 최적으로 실행시킨다.

### 스케줄링 큐

: 스케줄러가 프로세스 실행 순서를 정하는 방법

![image.png](attachment:ea9f9711-1343-4477-8d94-317bdefbac12:image.png)

→ **준비 큐**에 들어간 프로세스들 중 어떤 프로세스를 cpu에 할당할지 **우선 순위**에 따라서 정하는 것이다.

- 우선 순위를 정하는 방식

  : **스케줄링 알고리즘**을 사용하여, 우선 순위를 정한다.

먼저 스케줄링은 2가지로 분류된다.

- **선점형 스케줄링** (선점이란, 프로세스가 다른 프로세스를 중단 시키고 cpu에 할당되는 것을 뜻한다 - > 즉 뺐음)
    - 우선순위가 높은 프로세스가, cpu에 할당된 프로세스를 중단시키고, 먼저 실행시키는 것.
        - 자원 독점을 막을 수 있다.
        - 컨텍스트 스위칭이 많다.
- 비**선점형 스케줄링** (안뺐고 기다림)
    - 할당된 프로세스를 마무리하고 다음 프로세스를 진행한다.
        - 컨텍스트 스위칭이 적다.
        - 자원 독점이 있을 수 있다.

스케줄링 알고리즘

1. **선입 선처리 스케줄링(FCFS - First Come First Served)**

   : 단순 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링

    - 단점 : 호위 효과(convoy effect) : 긴 작업 하나 때문에, 뒤에 있는 짧은 작업들이 줄줄이 오래 기다리게 되는 현상
        - 은행에 전화해서 나는 몇시에 끝나는지 은행 끝나는 시간만 물어보면 되는데, 내 앞에 어떤 사람이 전화해서 기다리고 있는 상황, 그런데 내 앞에 전화한 사람은 대출 상담 받는라 20분이 필요한 상황이고, 나는 어쩔 수 없이 아무것도 못하고, 은행에서 대기 멜로디 들으며 내 차례를 기다리고 있는 상황이다. → 굉장히 비효율적임

2. **최단 작업 우선 스케줄링 (SJF - Shortest Job First)**

   : 금방 끝나는 작업을 먼저 처리하도록 하는 방법

    - 단점
        - 프로세스 처리시간이 얼마나 걸릴지 알아야한다는 것. → 이거 계산하고, 구하는 것 자체가 어렵다. 입출력을 동반한 프로세스라면, 동적으로 처리시간이 다르기 때문이다.
        - 기아상태 (Starvation) → 처리시간이 짧은 프로세스만 계속 우선적으로 처리하면, 처리시간이 긴 프로세스는 cpu에 할당 받지 못하는 무한정 기다림 상태인, 기아상태에 빠지게 된다.
        - 그래서 대부분 OS는 이 방식을 사용하지 않는다고 함.

3. **라운드 로빈 스케줄링 (RR - Round Robin)**

   : 라운드 로빈 : 중세 유럽에서 문서를 돌려가며 서명하던 방식에서 유래되었다고 함. → 즉, 돌아가면서 차례를 주는 방식이다. ( 주로 우선 순위 방식이나, 다른 스케줄링 방식에 합쳐져서 사용됨, 독단적으로 사용될 수도 있음)

   : FCFS 스케줄링 + 타임 슬라이스 (time slice)을 더한 방식으로 정해진 순서대로 프로세스 처리를 하지만, 정해진 시간(**time quantum**)이 지났는데도 프로세스를 완료하지 못한다면, 다시 프로세스를 준비 상태큐 맨뒤에 삽입하는 것이다.

    - 타임 슬라이스 크기가 중요하다. → 길면 convoy effect가 발생할 수 있고, 너무 짧으면 context switch가 너무 빈번하게 발생한다.

4. **최소 잔여 시간 우선 스케줄링 (SRT - Shortest Remaining Time)**

   : SJF + RR

   : 정해진 시간 만큼 CPU를 이용하고, 다음으로 cpu를 사용할 프로세스는 작업 시간이 가장 적은 프로세스를 선택한다.

   → 비현실적인 천재 이론이라고 (Chat gpt가 했음) \

    - 단점
        - 정확한 남은 시간 예측이 불가능
        - 선점이 자주 발생 → 잦은 오버헤드 (선점된 프로세스를 중단시키고, 작업 시간이 더 짧은 프로세스를 실행시킨다는 가정) → 오버헤드가 높으면, cpu 처리율이 떨어짐. cpu가 활동한 시간을 처리율이라고 하고, 처리량은 cpu가 완료한 프로세스 양을 뜻한다.
            - cpu버스트 타임: 프로세스가 CPU를 점유해서 쉬지 않고 연산을 수행하는 시간 구간 ( 즉 CPU만 사용하는 구간)

              ![image.png](attachment:9cc49b1f-847e-4da1-9d21-1166508774c8:image.png)
  

: 일반적으로 타임 퀀텀은 cpu 버스트 시간의 80%로 하는 것이 효율적이라고 함 ( cpu 버스트 타임을 구하는 것은 어렵기 때문에,

[실행된 모든 프로세스의 cpu 버스트 타임 / 이전에 실행된 모든 프로세스 수 x 0.8] 로 구한다

            ***** 식으로 나타내면
            
            ![image.png](attachment:b8ae2b5a-236d-4509-beb3-23be65a813d9:image.png)
            
        
        - 굶주림(Starvation) 발생
        - 복잡한 구현

5. **우선순위 스케줄링 (PS - Priority Scheduling)**

   : 프로세스에 우선 순위를 부여하고 우선 순위가 높은 프로세스부터 실행. → FCFS, SJF가 우선순위 스케줄링 방식이다. 더 큰 개념이라고 볼 수 있다.

    - 단점
        - 기아 현상이 존재한다. → 해결법( 에이징 기법(aging) - 오래 기다린 프로세스의 우선순위를 점차 높이는 방식)

6. **다단계 큐 스케줄링 (MQS - Multilevel Queue Scheduling)**

   : 여러개의 준비 큐를 준비하여, 준비 큐 마다 우선순위를 부여하고 각 큐마다 프로세스를 분류하고 다른 알고리즘을 적용한 스케줄링 방식이다.

   → 즉 큐마다 우선순위가 있고, 큐 안의 프로세스 마다 또 우선순위가 있는 방식이다.

   ex)

    - **대화형 프로세스 (Interactive process)** → 가장 높은 우선순위 큐 (예: RR 스케줄링)
    - **배치 프로세스 (Batch process)** → 중간 우선순위 큐 (예: FCFS 스케줄링)
    - **시스템 프로세스** → 낮은 우선순위 큐 (예: SJF 스케줄링)
        - 굉장히 구현하기 복잡하다.
        - 단점 : 프로세스간 이동이 불가능하다.

7. **다단계 피드백 큐 스케줄링 (MFQS - Multilevel Feedback Queue Scheduling)**

   : 각 큐를 프로세스 별로 분류하는 것이 아닌, 특정 기준을 가지고( ex) cpu 버스트 타임) 각 프로세스를 분류하고, 기아를 해결하기 위해 프로세스 간 이동이 가능하다.


---

다음시간에 계속….

### 멀티 스레드란?

- 스레드
    - 프로세스를 구성하는 실행 흐름의 단위이고, 하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.

- 스레드의 구성 요소
    - TID, PC, register value, stack
    - 실행에 필요한 최소한의 정보


![image.png](attachment:3a150973-96cd-4b34-a83a-c5fc82f44748:image.png)

![image.png](attachment:7b123966-a891-4d04-8f41-c02181ed1cf7:image.png)

- 스레드의 특징
    - 프로세스의 자원을 프로세스내 모든 스레드들은 공유한다.